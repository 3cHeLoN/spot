
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>A quick guide to Spot</title><meta name="generator" content="MATLAB 7.12"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2012-07-12"><meta name="DC.source" content="docguide_quick.m"><style type="text/css">

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head><body><div class="content"><h1>A quick guide to Spot</h1><!--introduction--><p>Using explicit matrices is not practical for some very large problems. Instead, we can use Spot operators. A Spot operator represents a matrix, and can be treated in a similar way, but it doesn't rely on the matrix itself to implement most of the methods. This short guide will show you how to make and use Spot operators.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Creating Operators</a></li><li><a href="#5">Applying Operators</a></li><li><a href="#7">Subset Assignment and Reference</a></li><li><a href="#10">Creating More Complex Operators</a></li></ul></div><h2>Creating Operators<a name="1"></a></h2><p>Create a new operator using the constructor from the appropriate operator class. For example, to make an operator A that consists of all ones, with three rows and two columns, use the <a href="matlab:doc('opOnes')">opOnes</a> class:</p><pre class="codeinput">A = opOnes(3,2)
</pre><pre class="codeoutput">A = 
  Spot operator: Ones(3,2)
    rows:      3    complex: no        
    cols:      2    type:    Ones      
</pre><p>We see that Spot displays some information about A when we leave off the semicolon, such as its construction, the number of rows and columns, and whether it is complex. We can also use the <a href="matlab:doc('opSpot/double')">double</a> method to construct the underlying matrix:</p><pre class="codeinput">double(A)
</pre><pre class="codeoutput">
ans =

     1     1
     1     1
     1     1

</pre><p>Operators can be easily added or subtracted. For example, make an operator B consisting of all twos and add it to A:</p><pre class="codeinput">B = 2*opOnes(3,2);
C = A + B;
double(C)
</pre><pre class="codeoutput">
ans =

     3     3
     3     3
     3     3

</pre><p>If you add a matrix and an operator, Spot will first automatically convert the matrix into a Spot operator using opMatrix. We can discover other information about the operator C by using the methods <a href="matlab:doc('opSpot/size')">size</a>, <a href="matlab:doc('opSpot/disp')">disp</a>, and <a href="matlab:doc('opSpot/whos')">whos</a>:</p><pre class="codeinput">whos <span class="string">C</span>
</pre><pre class="codeoutput">  Name      Size            Bytes  Class    Attributes

  C         3x2              1732  opSum              

</pre><h2>Applying Operators<a name="5"></a></h2><p>Spot operators can be multiplied by vectors just like MATLAB matrices. Make a vector x and apply C to it:</p><pre class="codeinput">x = [1;2];
y = C*x
</pre><pre class="codeoutput">
y =

     9
     9
     9

</pre><p>We can also multiply by the adjoint of an operator:</p><pre class="codeinput">w = [1;2;3];
z = C'*w;
</pre><h2>Subset Assignment and Reference<a name="7"></a></h2><p>If we are only interested in applying part of an operator, we can create a new operator that is a restriction of the existing one. The indexing used is the same as in MATLAB matrices; we can specify rows, columns, or individual elements, we can extract rows or columns in reverse, and we can repeat entries:</p><pre class="codeinput">x = [1;2;3;4;5];
A = opDiag(x); <span class="comment">% Create a 5x5 operator with x's values on its diagonal</span>
B = A(2:4,:);  <span class="comment">% Extract rows 2-4 of A</span>
double(B)
</pre><pre class="codeoutput">
ans =

     0     2     0     0     0
     0     0     3     0     0
     0     0     0     4     0

</pre><p>We can also assign values to a subset of an operator, again using the same syntax as in MATLAB matrices. The row and column indices we specify don't have to be within those of the original operator. In fact, we can specify indices that don't overlap at all with the original operator, and we will simply end up with a larger operator. Zero out part of A:</p><pre class="codeinput">A(1:2,:) = 0;
double(A)
</pre><pre class="codeoutput">
ans =

     0     0     0     0     0
     0     0     0     0     0
     0     0     3     0     0
     0     0     0     4     0
     0     0     0     0     5

</pre><p>Assign a new operator, C, to a subset of B:</p><pre class="codeinput">C = opOnes(2,2);
B(2:3,1:2) = C;
double(B)
</pre><pre class="codeoutput">
ans =

     0     2     0     0     0
     1     1     3     0     0
     1     1     0     4     0

</pre><h2>Creating More Complex Operators<a name="10"></a></h2><p>Spot operators can be combined into more complex operators using methods such as blkdiag and kron. Whenever a matrix is passed to one of these methods, it is automatically converted to a Spot operator. <a href="matlab:doc('opSpot/blkdiag')">blkdiag</a> takes a list of operators and matrices and creates a block diagonal operator:</p><pre class="codeinput">A = opOnes(2,2);
B = 2*opOnes(3,2);
C = 3*opOnes(1,3);
D = blkdiag(A, B, C);
double(D)
</pre><pre class="codeoutput">
ans =

     1     1     0     0     0     0     0
     1     1     0     0     0     0     0
     0     0     2     2     0     0     0
     0     0     2     2     0     0     0
     0     0     2     2     0     0     0
     0     0     0     0     3     3     3

</pre><p>We can also have the blocks overlap and create anti-diagonal operators (see <a href="usingmethods.html">"Using the Methods"</a>). Operators can be horizontally or vertically concatenated using opDictionary or opStack, or simply by passing them as elements in a matrix:</p><pre class="codeinput">E = 4*opOnes(2,3);
F = [A E];
double(F)
</pre><pre class="codeoutput">
ans =

     1     1     4     4     4
     1     1     4     4     4

</pre><p>The <a href="matlab:doc('opSpot/kron')">kron</a> method computes the Kronecker product of an arbitrary number of operators:</p><pre class="codeinput">G = opMatrix([2 1;3 0]);
H = opMatrix([1 2]);
K = kron(G, H);
double(K)
</pre><pre class="codeoutput">
ans =

     2     4     1     2
     3     6     0     0

</pre><p>For more information on how to work with Spot operators, see <a href="usingmethods.html">"Using the Methods"</a>. For a list of methods, see the <a href="http://www.cs.ubc.ca/labs/scl/spot/methods.html">"Index of Methods"</a>. For a list of the Spot operator classes and what they do, including fast transformations, random ensembles, and convolution, see the <a href="http://www.cs.ubc.ca/labs/scl/spot/operators.html">"Index of Operators"</a>.</p><p class="footer"><br>
      Published with MATLAB&reg; 7.12<br></p></div><!--
##### SOURCE BEGIN #####
%% A quick guide to Spot 
% Using explicit matrices is not practical for some very large problems.
% Instead, we can use Spot operators. A Spot operator represents a matrix,
% and can be treated in a similar way, but it doesn't rely on the matrix
% itself to implement most of the methods. This short guide will show you
% how to make and use Spot operators.

%% Creating Operators
% Create a new operator using the constructor from the appropriate
% operator class. For example, to make an operator A that consists of all
% ones, with three rows and two columns, use the <matlab:doc('opOnes') opOnes> class:

A = opOnes(3,2)

%%
% We see that Spot displays some information about A when we leave off the
% semicolon, such as its construction, the number of rows and columns, and
% whether it is complex. We can also use the <matlab:doc('opSpot/double') double>
% method to construct the underlying matrix:

double(A)

%%
% Operators can be easily added or subtracted. For example, make an
% operator B consisting of all twos and add it to A:

B = 2*opOnes(3,2);
C = A + B;
double(C)

%%
% If you add a matrix and an operator, Spot will first automatically
% convert the matrix into a Spot operator using opMatrix. We can discover
% other information about the operator C by using the methods
% <matlab:doc('opSpot/size') size>,
% <matlab:doc('opSpot/disp') disp>,
% and <matlab:doc('opSpot/whos') whos>:

whos C

%% Applying Operators
% Spot operators can be multiplied by vectors just like MATLAB matrices.
% Make a vector x and apply C to it:

x = [1;2];
y = C*x

%%
% We can also multiply by the adjoint of an operator:

w = [1;2;3];
z = C'*w;

%% Subset Assignment and Reference
% If we are only interested in applying part of an operator, we can create
% a new operator that is a restriction of the existing one. The indexing
% used is the same as in MATLAB matrices; we can specify rows, columns, or
% individual elements, we can extract rows or columns in reverse, and we
% can repeat entries:

x = [1;2;3;4;5];
A = opDiag(x); % Create a 5x5 operator with x's values on its diagonal
B = A(2:4,:);  % Extract rows 2-4 of A
double(B)

%%
% We can also assign values to a subset of an operator, again using the same
% syntax as in MATLAB matrices. The row and column indices we specify don't
% have to be within those of the original operator. In fact, we can specify
% indices that don't overlap at all with the original operator, and we will
% simply end up with a larger operator. Zero out part of A:

A(1:2,:) = 0;
double(A)

%%
% Assign a new operator, C, to a subset of B:

C = opOnes(2,2);
B(2:3,1:2) = C;
double(B)

%% Creating More Complex Operators
% Spot operators can be combined into more complex operators using methods
% such as blkdiag and kron. Whenever a matrix is passed to one of these
% methods, it is automatically converted to a Spot operator.
% <matlab:doc('opSpot/blkdiag') blkdiag> takes
% a list of operators and matrices and creates a block diagonal operator:

A = opOnes(2,2);
B = 2*opOnes(3,2);
C = 3*opOnes(1,3);
D = blkdiag(A, B, C);
double(D)

%%
% We can also have the blocks overlap and create anti-diagonal operators
% (see <usingmethods.html "Using the Methods">).
% Operators can be horizontally or vertically concatenated using
% opDictionary or opStack, or simply by passing them as elements in a matrix:

E = 4*opOnes(2,3);
F = [A E];
double(F)

%%
% The <matlab:doc('opSpot/kron') kron> method
% computes the Kronecker product of an arbitrary number of operators:

G = opMatrix([2 1;3 0]);
H = opMatrix([1 2]);
K = kron(G, H);
double(K)

%% 
% For more information on how to work with Spot operators, see
% <usingmethods.html "Using the Methods">.
% For a list of methods, see the <http://www.cs.ubc.ca/labs/scl/spot/methods.html "Index of Methods">.
% For a list of the Spot operator classes and what they do, including fast
% transformations, random ensembles, and convolution, see the
% <http://www.cs.ubc.ca/labs/scl/spot/operators.html "Index of Operators">.


##### SOURCE END #####
--></body></html>