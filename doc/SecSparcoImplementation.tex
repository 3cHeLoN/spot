\chapter[Advanced issues]{Advanced issues and implementation details}
\label{Sec:SparcoImplementation}

The implementation of \spot{} is done using a mix of Matlab classes
and function handles. Each operator is a class that includes
information regarding its size, complexity, type, as well as a handle
to a function that applies the operator or its conjugate. Most users
will only be concerned with the (abstract) class interface described
in Chapter~\ref{Sec:SparcoMetaOp}, and the elementary operator
constructors described in Chapter~\ref{Sec:SparcoOperators}.  In this
chapter we look at more advanced issues and discuss certain aspects of
the implementation.

Readers familiar with object-oriented programming may wonder why
\spot{} has not been implemented using a class hierarchy in which each
operator is derived from some parent class. The main reason for this
is that in the current implementation, only a single new file needs to
be created anywhere, without prescribed directory naming conventions,
to define a new operator. This greatly simplifies the extension of
\spot{} and requires a minimum of knowledge about the implementation.

\section{Adding a new operator}

We discuss the addition of new operator based on the implementation of
the \mlcmd{opDCT} operator (simplified to one-dimensional transforms),
which provides a good example of the structure of a typical basic
operator. The implementation of meta-operators will be discussed
briefly in Section~\ref{Sec:SparcoNewMeta}.

\begin{codeblock}
function op = opDCT(n)
% OPDCT  One-dimensional discrete cosine transform (DCT)
%
%    More information about the operator.
%

fun = @(x,mode) opDCT_intrnl(x,mode);
op  = sparcoOp(fun,n,n,0,'DCT');

% Implementation of internal functions

function y = opDCT_intrnl(x,mode)
if mode == 1
   y = dct(full(x));
else
   y = idct(full(x));
end
\end{codeblock}

The first line of this code tells Matlab this is a function that takes
a single argument $n$ and outputs a variable called $op$. Following
the comment that is displayed when typing \mlcmd{help opDCT}, there
are two lines that construct the \spot{} operator. The first of the
two lines creates an anonymous function called \mlcmd{fun} that takes
two arguments: $x$, and $\mathrm{mode}$. Each time the \mlcmd{fun}
function is called Matlab invokes \mlcmd{opDCT\_intrnl} with the given
parameters. In this case we could equivalently have written \mlcmd{fun
  = @opDCT\_intrnl}, however, the above construction allows us to pass
additional (constant) parameters, such as matrix size, to the
underlying function. Once we have created a handle to a function op
two parameters that takes care of the operator application we can
instantiate the \spot{} class. This is done in the second of the two
lines:
\begin{codeblock}
op = sparcoOp(fun,n,n,0,'DCT');
\end{codeblock}
We discuss this function in more detail in Section
\ref{Sec:SparcoOpConstructor}.

The remainder of the example code consists of the implementation of
the operator itself. In most cases, these functions take two
parameters: an input vector of appropriate length, and a \mlcmd{mode}
that determines whether the operator ($\mathrm{mode} = 1$), or its
conjugate ($\mathrm{mode} = 2$) should be applied. Additional
parameters can be passed during the construction of the \mlcmd{fun}
function handle. In this case we simply check the \mlcmd{mode} and
call either \mlcmd{dct} or \mlcmd{idct} on the dense input vector, and
return the result, $y$.  In general, special care needs to be taken to
ensure that application to sparse or complex vectors, as well as
vectors containing NaN or Inf values is properly dealt with.


\section{The \mlcmd{sparcoOp} class}

Much of the administrative work, as well as the implementation of all
syntax overloading is done in the \mlcmd{sparcoOp} class. While the
exact details of the implementation are not important, its outside
interface is. This interface consists of the constructor function to
create new instances of the class, and the various ways in which
existing instances can be manipulated. We discuss both topics below.

\subsection{The \mlcmd{sparcoOp} constructor}
\label{Sec:SparcoOpConstructor}

The \mlcmd{sparcoOp} constructor takes a total of six arguments:
\begin{codeblock}
sparcoOp(op,m,n,cflag,type,data)
\end{codeblock}
Using the function handle, matrix, or \sparco{} operator given by
\mlcmd{op}, this creates an operator of size $m\times $n. In most
cases a handle to a function taking care of the application of the
operator on a vector is given. For meta-operators it is convenient to
convert all input arguments (including matrices and existing
operators) to \sparco{} operator using the constructor function,
without having to check their types. When \mlcmd{op} is a matrix it is
automatically converted to a \sparco{} operator using the
\mlcmd{opMatrix} command. Because the operator size is known for
matrices and operators, input arguments \mlcmd{m} and \mlcmd{n} are
ignored for these values of \mlcmd{op}. When one or both of the
dimensions of the operator is zero, \mlcmd{sparcoOp} returns an empty
operator of desired size.


The three remaining arguments provide more information about the
operator and are optional and used only in conjunction with function
handle input. The \mlcmd{cflag} is a logical scalar indicating whether
or not the operator is complex. When omitted, a real operator is
assumed. The \mlcmd{type} argument gives a string describing the type
of the operator. This information is used when printing information
about the operator, e.g., when using \mlcmd{disp}. It is highly
recommended to specify a type string because it is an empty string by
default. When specifying the type, make sure it does is not already
used for an existing operator, because this may cause trouble when
printing the operator (see \mlcmd{char.m} in the class directory when
in doubt). The last argument is a \mlcmd{data} structure that gives
additional information about the operator. A more detailed description
about predefined fields of this structure is given in Section
\ref{Sec:SparcoOp.data}.


\subsection{Attributes of the sparcoOp class}
\label{Sec:SparcoRealComplex}\label{Sec:SparcoOpFields}
\label{Sec:SparcoOpFieldLinear}\label{Sec:SparcoCounters}
\label{Sec:SparcoOp.data}

Attributes of class instances can be accessed either directly using
\mlcmd{op.field}, or using the \mlcmd{get} and \mlcmd{set}
functions. The following fields are defined

\begin{longtable}{|p{2.0cm}p{9.8cm}|}
\hline
\mlcmd{adjoint} & logic scalar that indicates whether the operator is
                  in adjoint mode or not \\
\mlcmd{linear}  & logic scalar that is set to true if the operator is
                  linear \\
\mlcmd{scalar}  & scalar multiplication factor associated with
                  operator \\ 
\mlcmd{counter} & a (possibly empty) string giving the name of a
                  variable in the base workspace that counts the
                  number of multiplications with the operator and its
                  adjoint \\
\mlcmd{type}    & a read-only string giving the type of the operator \\
\mlcmd{cflag}   & logic scalar that is set to true if the operator is
                  complex\\
\mlcmd{data}    & structure that contains additional, often
                  operator specific, information \\
\hline
\end{longtable}

\paragraph*{cflag} The \mlcmd{cflag} attribute indicates whether the
operator is complex or real. When combining operators, \spot{} has to
be conservative in deciding what value to use; it is not possible to
know in advance whether imaginary parts cancel out since each operator
is considered as a black box. This default behavior can be overridden
by the user by setting the \mlcmd{cflag}. Note that the \mlcmd{cflag}
attribute is concerned only with the complexity of the operator
itself, and not with the possible value of the \mlcmd{scalar}
field. For example, when we write \mlcmd{A = sqrt(-1) * opDCT(16)}, we
have \mlcmd{A.cflag = 0}, since $A$ is essentially the DCT
operator. Consequently, multiplying $A$ by some other purely imaginary
scalar yields a real operator. If we had updated the \mlcmd{cflag}
field, this information would have been lost. To query the complexity
of an operator it is recommended to use \mlcmd{isreal} function, which
does take the scalar quantity into account. The \mlcmd{clfag} is
mostly for internal use, but may be useful when developing a new
meta-operator.

\paragraph*{type} The \mlcmd{type} field is predominantly used when
displaying an operator. Besides this it is often used in the
development of self-aware meta-operators, as it allows them to check
if they apply a function to itself (for example, applying the complex
conjugate to itself will cancel the conjugation).

\paragraph*{counter} The \mlcmd{counter} field can be set to keep
track of the number of applications of the operator. This is done by
updating the associated variable in the base workspace. These counter
variables consist of two entries respectively counting the number of
direct and adjoint applications of the operator:
\begin{codeblock}
>> A = opMatrix(randn(3,4));
>> A.counter = 'aCounter';
>> A*randn(4,1); A*randn(4,1); A'*randn(3,1);
>> disp(aCounter)
     2     1
>> B = opBlockDiag(3,A);
>> B*randn(12,1);
>> disp(aCounter)
     5     1
\end{codeblock}
Note that writing \mlcmd{C = A'}, gives a new operator, which does
share the same counter as $A$. Multiplication by $C$ will be counted
as one multiplication by $A^H$ and vice versa though.

\paragraph*{adjoint} The \mlcmd{adjoint} attribute can be used to for
the complex transpose of the operator. Care has to be taken when
counters are associated with the operator whose \mlcmd{adjoint}
property is modified. Continuing from the above example:
\begin{codeblock}
>> disp(aCounter);
     5     1
>> A.adjoint = true;
>> A*randn(3,1);
>> disp(aCounter);
     5     2
\end{codeblock}
Although we multiply by $A$ itself (not its transpose), it is the
second entry of the counter variable that is updated. This is because
the counter variable was associated with the original $A$ and by
multiplying by the new $A$, we actually multiply by the transpose of
the original. We considered interchanging the counter entries upon
modifying the adjoint flag. However this may corrupt the counter when
writing \mlcmd{B = set(A,'adjoint',1)}, followed by multiplications
by $A$ (which still expects the original ordering).

\paragraph*{scalar} The \mlcmd{scalar} field provides a scalar
multiplier with which the operator is scaled. This scalar, when
complex, applies to the operator based on its present adjoint
state. When the adjoint state is changed by modifying the
\mlcmd{adjoint} property or by applying the complex transpose
operator, the scalar will automatically be changed to its complex
conjugate.

\paragraph*{Using the set command} When setting operator properties
using the \mlcmd{set} command, you must specify a left-hand side
variable:
\begin{codeblock}
A = set(A,'cflag',1)}
\end{codeblock}
otherwise the changes gets lost; a new variable is created which is
then immediately discarded. It is therefore usually easier to set the
fields directly using, e.g., \mlcmd{A.cflag = 1}, unless setting
multiple properties at once:
\begin{codeblock}
A = set(A,'linear',1,'cflag',0,'scalar',3)
\end{codeblock}
Finally, the \mlcmd{isfield} command can be used to check if a given
field is provided by the \mlcmd{sparcoOp} class.

\section{Adding a new meta-operator}\label{Sec:SparcoNewMeta}

Developing meta-operators is more complicated than regular operators,
and usually requires much more administrative code. In this section we
briefly discuss a number of things that need to be kept in mind when
developing a new meta-operator.

The first thing to do when writing a constructor function for a
meta-operator is to check the input arguments, and convert all
matrices to operators using the \mlcmd{sparcoOp}
function. Compatibility of the operators then needs to be checked, and
the complexity and linearity of the resulting operator determined. The
next step then, like that of basic operators, is to create a handle to
a function implementing multiplication by the meta-operator and its
complex transpose.

By their very nature meta-operators always need to maintain a list of
operators they depend on. This list is easily passed to the
multiplication function in the definition of the anonymous function:
\begin{codeblock}
fun = @(x,mode) intrnl\_fun(oplist,x,mode);
\end{codeblock}
This list is also required when displaying the operator and for
cell-indexing (see Section \ref{Sec:CellIndexing}). To facilitate
this, the \mlcmd{data} structure has a reserved field called
\mlcmd{oplist}, which should be set prior to calling \mlcmd{sparcoOp}
to complete the operator:
\begin{codeblock}
data = struct();
data.oplist = oplist;
fun         = @(x,mode) ...;
op          = sparcoOp(fun,m,n,cflag,name,data);
\end{codeblock}
Other attributes, such as the linearity should be set after the
operator is created.

When certain meta-operators, such as \mlcmd{opConj} and
\mlcmd{opInverse}, are applied to themselves they can often be
simplified. When doing such simplifications it is important to check
the \mlcmd{adjoint} and \mlcmd{scalar} fields. For example, when
unpacking a conjugate operator, any scalar multiplier associated with
the outer operator has to be conjugated and multiplied by the original
scalar. When manipulating the scalars, it is best to do this by
setting the \mlcmd{scalar} field directly. This avoid accidental
multiplication by scalar vector resulting an a numeric vector rather
than a new operator.


\section{Cell indexing}\label{Sec:CellIndexing}

In \spot{} the cell-indexing operation is overloaded to provide
(read-only) access to the operators that make up a given
operator. This is best illustrated by a simple example. Assume we have
the following definitions:
\begin{codeblock}
A = opEye(8);
B = opFFT(8);
C = opGaussian(8,16);
D = [A,B];
E = C + D;
F = C + D + 2;
\end{codeblock}
Then
\begin{codeblock}
>> D{2}
ans is a linear Sparco operator of size 8 x 8
         FFT(8,8)
>> E{1}
ans is a linear Sparco operator of size 8 x 16
         Gaussian(8,16)
>> E{2,1}
ans is a linear Sparco operator of size 8 x 8
         Eye(8,8)
>> data = F{2:3}
data =
    [8x16 sparcoOp]    [8x16 sparcoOp]
\end{codeblock}
By combining cell indexing with property access it is possible to
obtain the properties of a range of sub-operators:
\begin{codeblock}
>> F{:}.cflag
ans =
    [0]    [1]    [0]
>> F{2}.data
ans =
    oplist: {[8x8 sparcoOp]  [8x8 sparcoOp]}
>> F{2}.data.oplist{1}
ans is a linear Sparco operator of size 8 x 8
         Eye(8,8)
\end{codeblock}
As mentioned above, cell indexing is read-only, and intended only to
get information. It is not possible to modify or set properties of
underlying operators.

Operations such as \mlcmd{opFoG}, \mlcmd{opSum}, and
\mlcmd{opDictionary} do not check whether their arguments are of the
same type (in that case they could be unwrapped and added to the
operator list). This is done mostly to keep operators as a unit.
Consider the following example:
\begin{codeblock}
C = A * B;
E = C * A
\end{codeblock}
In this case we would like \mlcmd{E} to consist of two operator,
instead of three which would be the case when expanding \mlcmd{C} to
give \mlcmd{E = A*B*D}.  This does bring with it a slight
problem. When matlab sees \mlcmd{A*B*D} it will call the \spot{}
multiplication operator first on \mlcmd{A*B} and then multiply that
the result by \mlcmd{D}, giving \mlcmd{(A*B)*D}. Setting \mlcmd{E =
  A*B*D} would then consist of two operators: \mlcmd{(A*B)} and
\mlcmd{D}, which is unnatural. To overcome this situation and make it
more intuitive \spot{} checks whether the operators it sees are
named. If they are not named we can assume they are intermediate
results and expansion is done. This means that \mlcmd{E = A*B*D} does
consist of three operators. This remains so even when \mlcmd{B} is
itself a product of operators. The same applies to addition and
subtraction. In dictionaries, \spot{} gets all elements at once so no
effort is required here. Scalar multiplication is included in the
appropriate operator:
\begin{codeblock}
>> X = A + A + 3*(A+A);
>> X{3}
ans is a linear Sparco operator of size 8 x 8
         3 * (Eye(8,8) + Eye(8,8))
\end{codeblock}

\section{Known issues}

\paragraph{Cell indexing} When using cell indexing on a compound
operator to get its constituent operators, it is not possible to use
\mlcmd{end} to get the last operator. The reason for this is that,
when seeing the \mlcmd{end} keyword, \matlab{} calls the \mlcmd{end}
function implemented by the operator to get the corresponding
number. Unfortunately, it does not specify whether \mlcmd{end} was
used within array indexing \mlcmd{[]} or within cell indexing
\mlcmd{\{\}}. It was therefore decided to always return the desired
dimension of the operator rather than the number of operators used to
create it. This will lead to somewhat unexpected results when using
the \mlcmd{end} keyword within cell indexing.

\paragraph{Scalar multiplication} When post-multiplying an $n\times 1$
\sparco{} operator by a scalar this will be interpreted as a
matrix-vector operation giving a numeric result, rather than a scaled
version of the operator (which is generally the case). This follows
from the rule that multiplication between an operator and an
appropriately sized matrix or vector leads to the evaluation of the
product. Scalar multiplication is considered only after this rule has
been applied. The reason behind this choice in priority is that the
conversion of an operator to an array, \mlcmd{double(op)}, would
otherwise not work properly for $n\times 1$ operators. A similar
situation arises when pre-multiplying a $1\times n$ operator by a
scalar. When scalar multiplication of such operators is needed you can
either pre-, respectively post-multiply by a scalar, thereby avoiding
evaluation, or directly set the \mlcmd{.scalar} property op the
operator.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "manual"
%%% End: 
